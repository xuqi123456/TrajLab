package whu.edu.cn.trajlab.query.coprocessor;

import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Polygon;
import scala.Tuple2;
import whu.edu.cn.trajlab.base.point.BasePoint;
import whu.edu.cn.trajlab.base.point.TrajPoint;
import whu.edu.cn.trajlab.base.util.DiscreteFrechetDistance;
import whu.edu.cn.trajlab.base.util.GeoUtils;
import whu.edu.cn.trajlab.base.util.SerializerUtils;
import whu.edu.cn.trajlab.db.constant.DBConstants;
import whu.edu.cn.trajlab.db.database.Database;
import whu.edu.cn.trajlab.db.database.table.IndexTable;
import whu.edu.cn.trajlab.db.database.util.TrajectorySerdeUtils;
import whu.edu.cn.trajlab.db.datatypes.TimeLine;
import whu.edu.cn.trajlab.base.mbr.MinimumBoundingBox;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.Coprocessor;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.CoprocessorService;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.filter.MultiRowRangeFilter;
import org.apache.hadoop.hbase.regionserver.InternalScanner;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import whu.edu.cn.trajlab.base.trajectory.Trajectory;
import whu.edu.cn.trajlab.query.coprocessor.autogenerated.QueryCondition;
import whu.edu.cn.trajlab.query.util.BasicDateUtils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @author xuqi
 * @date 2023/12/04
 */
public class STQueryEndPoint extends QueryCondition.QueryService
    implements Coprocessor, CoprocessorService {

  private final Logger logger = LoggerFactory.getLogger(STQueryEndPoint.class);
  private RegionCoprocessorEnvironment env;
  private Database instance = null;

  @Override
  public void query(
      RpcController controller,
      QueryCondition.QueryRequest request,
      RpcCallback<QueryCondition.QueryResponse> done) {
    QueryCondition.QueryMethod queryOperation = request.getQueryOperation();
    List<QueryCondition.Range> rangeList = request.getRangeList();
    // 将Range List按照是否需要二次判断分组，并生成两个Scan
    List<MarkedScan> markedScans = null;
    try {
      markedScans = getTowScan(rangeList);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    List<QueryCondition.TrajectoryResult> trajectoryResults = new ArrayList<>();
    switch (queryOperation) {
      case ST:
        {
          QueryCondition.STQueryRequest stRequest = request.getSt();
          boolean filterBeforeLookFullRow = stRequest.getFilterBeforeLookFullRow();
          try {
            // 扫描, 解析结果
            for (MarkedScan markedScan : markedScans) {
              Scan scan = markedScan.scan;
              InternalScanner scanner = env.getRegion().getScanner(scan);
              List<Cell> cells = new ArrayList<>();
              boolean hasMore = scanner.next(cells) || !cells.isEmpty();
              while (hasMore) {
                Result result = Result.create(cells);
                if (!markedScan.needFilter) {
                  if (!TrajectorySerdeUtils.isMainIndexed(result)) {
                    result = getMainIndexedResult(result);
                  }
                  trajectoryResults.add(buildTrajectoryResult(result));
                } else {
                  // 如果当前索引是辅助索引，且不需要在回表查询之前作粗过滤，则先回表查询。
                  if (!TrajectorySerdeUtils.isMainIndexed(result) && !filterBeforeLookFullRow) {
                    result = getMainIndexedResult(result);
                  }
                  // 使用pos code, mbr等粗过滤
                  if (coarseFilter(result, stRequest)) {
                    // 如果filterBeforeLookFullRow为真，则此时result仍然是辅助索引
                    // 相当于先通过了初步过滤，现在要回表查询。
                    if (!TrajectorySerdeUtils.isMainIndexed(result)) {
                      result = getMainIndexedResult(result);
                    }
                    // 使用point list作精过滤
                    if (fineFilter(result, stRequest)) {
                      trajectoryResults.add(buildTrajectoryResult(result));
                    }
                  }
                }
                // 读取下一行
                cells.clear();
                hasMore = scanner.next(cells) || !cells.isEmpty();
              }
            }
          } catch (IOException e) {
            e.printStackTrace();
          }
          break;
        }
      case KNN:
        {
          QueryCondition.KNNQueryRequest knn = request.getKnn();
          try {
            // 扫描, 解析结果
            for (MarkedScan markedScan : markedScans) {
              Scan scan = markedScan.scan;
              InternalScanner scanner = env.getRegion().getScanner(scan);
              List<Cell> cells = new ArrayList<>();
              boolean hasMore = scanner.next(cells) || !cells.isEmpty();
              while (hasMore) {
                Result result = Result.create(cells);
                // 如果当前索引是辅助索引，且不需要在回表查询之前作粗过滤，则先回表查询。
                if (!TrajectorySerdeUtils.isMainIndexed(result)) {
                  result = getMainIndexedResult(result);
                }
                if (knnFilter(result, knn)) {
                  trajectoryResults.add(buildTrajectoryResult(result));
                }
                // 读取下一行
                cells.clear();
                hasMore = scanner.next(cells) || !cells.isEmpty();
              }
            }
          } catch (IOException e) {
            e.printStackTrace();
          }
          break;
        }
      case SIMILAR:
        {
          QueryCondition.SimilarQueryRequest sim = request.getSim();
          try {
            // 扫描, 解析结果
            for (MarkedScan markedScan : markedScans) {
              Scan scan = markedScan.scan;
              InternalScanner scanner = env.getRegion().getScanner(scan);
              List<Cell> cells = new ArrayList<>();
              boolean hasMore = scanner.next(cells) || !cells.isEmpty();
              while (hasMore) {
                Result result = Result.create(cells);
                // 如果当前索引是辅助索引，且不需要在回表查询之前作粗过滤，则先回表查询。
                if (!TrajectorySerdeUtils.isMainIndexed(result)) {
                  result = getMainIndexedResult(result);
                }
                if (simFilter(result, sim)) {
                  if (fineSimFilter(result, sim)) {
                    trajectoryResults.add(buildTrajectoryResult(result));
                  }
                }
                // 读取下一行
                cells.clear();
                hasMore = scanner.next(cells) || !cells.isEmpty();
              }
            }
          } catch (IOException e) {
            e.printStackTrace();
          }
          break;
        }
      case ACCOMPANY:
        {
          QueryCondition.AccompanyQueryRequest acc = request.getAcc();
          try {
            // 扫描, 解析结果
            for (MarkedScan markedScan : markedScans) {
              Scan scan = markedScan.scan;
              InternalScanner scanner = env.getRegion().getScanner(scan);
              List<Cell> cells = new ArrayList<>();
              boolean hasMore = scanner.next(cells) || !cells.isEmpty();
              while (hasMore) {
                Result result = Result.create(cells);
                // 如果当前索引是辅助索引，且不需要在回表查询之前作粗过滤，则先回表查询。
                if (!TrajectorySerdeUtils.isMainIndexed(result)) {
                  result = getMainIndexedResult(result);
                }
                if (accFilter(result, acc)) {
                  if (fineAccFilter(result, acc)) {
                    trajectoryResults.add(buildTrajectoryResult(result));
                  }
                }
                // 读取下一行
                cells.clear();
                hasMore = scanner.next(cells) || !cells.isEmpty();
              }
            }
          } catch (IOException e) {
            e.printStackTrace();
          }
          break;
        }
    }

    QueryCondition.QueryResponse response =
        QueryCondition.QueryResponse.newBuilder().addAllList(trajectoryResults).build();
    done.run(response);
  }

  /**
   * Get a scan list with at most size 2 to scan ranges that need / don't need server-side column
   * filter respectively.
   *
   * @return The scan object at offset 0 will read all records that <strong>absolutely</strong> meet
   *     the query request, the other object at offset 1 will read all records that
   *     <strong>may</strong> meet the query request according to the row key coding strategy.
   * @throws IOException
   */
  private List<MarkedScan> getTowScan(List<QueryCondition.Range> rangeList) throws IOException {
    List<MultiRowRangeFilter.RowRange> rowRangeListConfirmed = new ArrayList<>(rangeList.size());
    List<MultiRowRangeFilter.RowRange> rowRangeListSuspected = new ArrayList<>(rangeList.size());
    for (QueryCondition.Range range : rangeList) {
      List<MultiRowRangeFilter.RowRange> listToAdd =
          range.getContained() ? rowRangeListConfirmed : rowRangeListSuspected;
      listToAdd.add(
          new MultiRowRangeFilter.RowRange(
              range.getStart().toByteArray(), true, range.getEnd().toByteArray(), false));
    }
    List<MarkedScan> markedScans = new LinkedList<>();
    if (!rowRangeListConfirmed.isEmpty()) {
      Scan scan0 = buildScan();
      scan0.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.PTR_QUALIFIER);
      scan0.setFilter(new MultiRowRangeFilter(rowRangeListConfirmed));
      markedScans.add(new MarkedScan(scan0, false));
    }
    if (!rowRangeListSuspected.isEmpty()) {
      Scan scan1 = buildScan();
      scan1.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.PTR_QUALIFIER);
      scan1.setFilter(new MultiRowRangeFilter(rowRangeListSuspected));
      markedScans.add(new MarkedScan(scan1, true));
    }
    return markedScans;
  }

  /** 获取含以下列的scan: mbr, start, end, plist, mo_id, traj_id, ptr */
  protected Scan buildScan() {
    Scan scan = new Scan();
    scan.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.MBR_QUALIFIER);
    scan.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.START_POINT_QUALIFIER);
    scan.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.END_POINT_QUALIFIER);
    scan.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.TRAJ_POINTS_QUALIFIER);
    scan.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.OBJECT_ID_QUALIFIER);
    scan.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.TRAJECTORY_ID_QUALIFIER);
    scan.addColumn(DBConstants.COLUMN_FAMILY, DBConstants.PTR_QUALIFIER);
    return scan;
  }

  /** 基于辅助索引表的行回表，获取主索引表的行： 先从Instance获取数据集的名称，再找到coreIndex */
  private Result getMainIndexedResult(Result result) throws IOException {
    return instance
        .getDataSet(IndexTable.extractDataSetName(env.getRegionInfo().getTable().getNameAsString()))
        .getCoreIndexTable()
        .get(new Get(result.getValue(DBConstants.COLUMN_FAMILY, DBConstants.PTR_QUALIFIER)));
  }

  /**
   * 基于result内以单独列存储的信息作粗过滤, 例如:mbr, start_time, end_time等.
   *
   * @param result
   * @param queryRequest
   * @return
   */
  protected boolean coarseFilter(Result result, QueryCondition.STQueryRequest queryRequest) {
    WKTReader wktReader = new WKTReader();
    boolean spatialValidate = false;
    boolean temporalValidate = false;
    // 利用MBR对QueryRequest中的空间约束作初步判断
    if (queryRequest.hasSpatialQueryWindow()) {
      try {
        Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
        MinimumBoundingBox mbr = TrajectorySerdeUtils.getTrajectoryMBR(result);
        if (queryRequest.getSpatialQueryType() == QueryCondition.QueryType.CONTAIN) {
          spatialValidate = queryGeom.contains(mbr.toPolygon(4326));
        } else {
          spatialValidate = queryGeom.intersects(mbr.toPolygon(4326));
        }
      } catch (ParseException | IOException e) {
        e.printStackTrace();
      }
    } else {
      spatialValidate = true;
    }
    if (queryRequest.hasTemporalQueryWindows()) {
      List<QueryCondition.TemporalQueryWindow> temporalQueryWindowList =
          queryRequest.getTemporalQueryWindows().getTemporalQueryWindowList();
      // start and end time of the traj
      TimeLine trajTimeLine = TrajectorySerdeUtils.getTrajectoryTimeLine(result);
      for (QueryCondition.TemporalQueryWindow temporalQueryWindow : temporalQueryWindowList) {
        TimeLine queryTimeLine =
            new TimeLine(
                BasicDateUtils.timeToZonedTime(temporalQueryWindow.getStartMs()),
                BasicDateUtils.timeToZonedTime(temporalQueryWindow.getEndMs()));
        if (queryRequest.getTemporalQueryType() == QueryCondition.QueryType.CONTAIN) {
          temporalValidate = temporalValidate || queryTimeLine.contain(trajTimeLine);
        } else {
          temporalValidate = temporalValidate || queryTimeLine.intersect(trajTimeLine);
        }
      }
    } else {
      temporalValidate = true;
    }
    return spatialValidate && temporalValidate;
  }

  /**
   * 根据需要配置具体的精过滤条件, 对于最常用的时间\空间条件, 已提供了如下开箱即用的精过滤方法:
   *
   * @see STQueryEndPoint#spatialFineFilter(Result, QueryCondition.STQueryRequest)
   */
  protected boolean fineFilter(Result result, QueryCondition.STQueryRequest stRequest)
      throws IOException {
    boolean validate = true;
    if (stRequest.hasSpatialQueryWindow()) {
      validate = spatialFineFilter(result, stRequest);
    }
    return validate;
  }

  /**
   * Fine filter based on trajectory line string.
   *
   * @param result A main indexed trajectory row.
   * @param stRequest To get spatial query polygon and spatial query type.
   * @return Whether the result trajectory satisfies queryCondition.
   */
  protected boolean spatialFineFilter(Result result, QueryCondition.STQueryRequest stRequest)
      throws IOException {
    Trajectory trajectory = TrajectorySerdeUtils.mainRowToTrajectory(result);
    WKTReader wktReader = new WKTReader();
    try {
      Geometry queryGeom = wktReader.read(stRequest.getSpatialQueryWindow().getWkt());
      if (stRequest.getSpatialQueryType() == QueryCondition.QueryType.CONTAIN) {
        return queryGeom.contains(trajectory.getLineString());
      }
      return queryGeom.intersects(trajectory.getLineString());
    } catch (ParseException e) {
      e.printStackTrace();
    }
    return false;
  }

  protected boolean timeFilter(
      Result result, QueryCondition.TemporalQueryWindow temporalQueryWindow) {
    if (temporalQueryWindow == null) return true;
    TimeLine trajTimeLine = TrajectorySerdeUtils.getTrajectoryTimeLine(result);
    TimeLine queryTimeLine =
        new TimeLine(
            BasicDateUtils.timeToZonedTime(temporalQueryWindow.getStartMs()),
            BasicDateUtils.timeToZonedTime(temporalQueryWindow.getEndMs()));
    return queryTimeLine.intersect(trajTimeLine);
  }

  protected boolean knnFilter(Result result, QueryCondition.KNNQueryRequest knnQueryRequest)
      throws IOException {
    MinimumBoundingBox mbr = TrajectorySerdeUtils.getTrajectoryMBR(result);
    Polygon mbrPolygon = mbr.toPolygon(4326);
    double maxDis = knnQueryRequest.getDistance();
    if (knnQueryRequest.hasPoint()) {
      // 使用DistanceOp计算最短距离
      BasePoint point =
          (BasePoint)
              SerializerUtils.deserializeObject(
                  knnQueryRequest.getPoint().toByteArray(), BasePoint.class);

      double distance = GeoUtils.nearDistanceOp(point, mbrPolygon);
      return distance <= maxDis && timeFilter(result, knnQueryRequest.getTemporalQueryWindow());
    } else {
      Trajectory trajectory =
          (Trajectory)
              SerializerUtils.deserializeObject(
                  knnQueryRequest.getTrajectory().toByteArray(), Trajectory.class);
      double distance = Double.MAX_VALUE;
      for (TrajPoint trajPoint : trajectory.getPointList()) {
        double pointDis = GeoUtils.nearDistanceOp(trajPoint, mbrPolygon);
        distance = Math.min(distance, pointDis);
      }
      return distance <= maxDis && timeFilter(result, knnQueryRequest.getTemporalQueryWindow());
    }
  }

  protected boolean simFilter(Result result, QueryCondition.SimilarQueryRequest similarQueryRequest)
      throws IOException {
    MinimumBoundingBox mbr = TrajectorySerdeUtils.getTrajectoryMBR(result);
    double maxDis = similarQueryRequest.getDistance();
    Trajectory centralTrajectory =
        (Trajectory)
            SerializerUtils.deserializeObject(
                similarQueryRequest.getTrajectory().toByteArray(), Trajectory.class);
    Envelope envelopeInternal = centralTrajectory.getLineString().getEnvelopeInternal();
    envelopeInternal.expandBy(maxDis);
    TrajPoint startPoint = centralTrajectory.getTrajectoryFeatures().getStartPoint();
    TrajPoint endPoint = centralTrajectory.getTrajectoryFeatures().getEndPoint();
    if (!envelopeInternal.contains(mbr)) return false;
    Tuple2<TrajPoint, TrajPoint> trajectorySEPoint =
        TrajectorySerdeUtils.getTrajectorySEPoint(result);
    double distance1 = GeoUtils.getEuclideanDistanceKM(startPoint, trajectorySEPoint._1);
    double distance2 = GeoUtils.getEuclideanDistanceKM(endPoint, trajectorySEPoint._2);

    return GeoUtils.getDegreeFromKm(distance1) <= maxDis
        && GeoUtils.getDegreeFromKm(distance2) <= maxDis
        && timeFilter(result, similarQueryRequest.getTemporalQueryWindow());
  }

  protected boolean accFilter(
      Result result, QueryCondition.AccompanyQueryRequest accompanyQueryRequest)
      throws IOException {

    MinimumBoundingBox mbr = TrajectorySerdeUtils.getTrajectoryMBR(result);
    TimeLine tLine = TrajectorySerdeUtils.getTrajectoryTimeLine(result);

    Trajectory centralTrajectory =
        (Trajectory)
            SerializerUtils.deserializeObject(
                accompanyQueryRequest.getTrajectory().toByteArray(), Trajectory.class);
    int startPointCount = accompanyQueryRequest.getStartPoint();
    int k = accompanyQueryRequest.getK();
    //空间缓冲区
    List<TrajPoint> trajPoints =
        centralTrajectory.getPointList().subList(startPointCount, startPointCount + k);
    MinimumBoundingBox minimumBoundingBox = GeoUtils.calMinimumBoundingBox(trajPoints);
    minimumBoundingBox.expandBy(accompanyQueryRequest.getDistance());
    //时间缓冲区
    long timeInterval = accompanyQueryRequest.getTimeInterval();
    TimeLine timeLine =
        new TimeLine(
            trajPoints.get(0).getTimestamp().minusNanos(timeInterval * 1000000),
            trajPoints.get(trajPoints.size() - 1).getTimestamp().plusNanos(timeInterval * 1000000));
    return mbr.isIntersects(minimumBoundingBox) && tLine.intersect(timeLine);
  }

  protected boolean fineSimFilter(
      Result result, QueryCondition.SimilarQueryRequest similarQueryRequest) throws IOException {
    double maxDis = similarQueryRequest.getDistance();
    Trajectory resultTrajectory = TrajectorySerdeUtils.getTrajectoryFromResult(result);
    Trajectory centralTrajectory =
        (Trajectory)
            SerializerUtils.deserializeObject(
                similarQueryRequest.getTrajectory().toByteArray(), Trajectory.class);
    double dfd =
        DiscreteFrechetDistance.calculateDFD(
            resultTrajectory.getLineString(), centralTrajectory.getLineString());
    return GeoUtils.getDegreeFromKm(dfd) <= maxDis;
  }

  protected boolean fineAccFilter(
      Result result, QueryCondition.AccompanyQueryRequest accompanyQueryRequest)
      throws IOException {
    Trajectory trajectory = TrajectorySerdeUtils.mainRowToTrajectory(result);
    TimeLine tLine = TrajectorySerdeUtils.getTrajectoryTimeLine(result);

    Trajectory centralTrajectory =
            (Trajectory)
                    SerializerUtils.deserializeObject(
                            accompanyQueryRequest.getTrajectory().toByteArray(), Trajectory.class);
    int startPointCount = accompanyQueryRequest.getStartPoint();
    int k = accompanyQueryRequest.getK();
    List<TrajPoint> trajPoints =
            centralTrajectory.getPointList().subList(startPointCount, startPointCount + k);
    double distance = accompanyQueryRequest.getDistance();
    long timeInterval = accompanyQueryRequest.getTimeInterval();

    for (TrajPoint trajPoint : trajPoints) {
      Geometry buffer = trajPoint.buffer(distance);
      TimeLine timeLine =
              new TimeLine(
                      trajPoint.getTimestamp().minusNanos(timeInterval * 1000000),
                      trajPoint.getTimestamp().plusNanos(timeInterval * 1000000));
      if (!buffer.intersects(trajectory.getLineString()) || !timeLine.intersect(tLine)) return false;
    }
    return true;
  }

  @Override
  public void start(CoprocessorEnvironment env) throws IOException {
    if (env instanceof RegionCoprocessorEnvironment) {
      this.env = (RegionCoprocessorEnvironment) env;
      this.instance = Database.getInstance();
    } else {
      throw new CoprocessorException("Failed to init coprocessor env.");
    }
  }

  @Override
  public void stop(CoprocessorEnvironment env) throws IOException {
    logger.warn("STQueryEndPoint is unregistered, running stop() hook!");
  }

  @Override
  public Service getService() {
    return this;
  }

  static class MarkedScan {

    Scan scan;
    boolean needFilter;

    MarkedScan(Scan scan, boolean needFilter) {
      this.scan = scan;
      this.needFilter = needFilter;
    }
  }

  private QueryCondition.TrajectoryResult buildTrajectoryResult(Result result) {
    return QueryCondition.TrajectoryResult.newBuilder()
        .setRowkey(ByteString.copyFrom(result.getRow()))
        .setTrajPointList(
            ByteString.copyFrom(
                TrajectorySerdeUtils.getByteArrayByQualifier(
                    result, DBConstants.TRAJ_POINTS_QUALIFIER)))
        .setObjectId(
            ByteString.copyFrom(
                TrajectorySerdeUtils.getByteArrayByQualifier(
                    result, DBConstants.OBJECT_ID_QUALIFIER)))
        .setTid(
            ByteString.copyFrom(
                TrajectorySerdeUtils.getByteArrayByQualifier(
                    result, DBConstants.TRAJECTORY_ID_QUALIFIER)))
        .build();
  }
}
