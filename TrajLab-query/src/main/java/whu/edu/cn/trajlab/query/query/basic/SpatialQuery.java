package whu.edu.cn.trajlab.query.query.basic;

import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import whu.edu.cn.trajlab.db.condition.IDTemporalQueryCondition;
import whu.edu.cn.trajlab.db.datatypes.TimeLine;
import whu.edu.cn.trajlab.query.coprocessor.STCoprocessorQuery;
import whu.edu.cn.trajlab.db.condition.AbstractQueryCondition;
import whu.edu.cn.trajlab.db.condition.SpatialQueryCondition;
import whu.edu.cn.trajlab.db.database.DataSet;
import whu.edu.cn.trajlab.db.database.meta.IndexMeta;
import whu.edu.cn.trajlab.db.database.table.IndexTable;
import whu.edu.cn.trajlab.db.enums.IndexType;
import whu.edu.cn.trajlab.db.index.RowKeyRange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import whu.edu.cn.trajlab.base.trajectory.Trajectory;
import whu.edu.cn.trajlab.query.coprocessor.autogenerated.QueryCondition;

import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * @author xuqi
 * @date 2023/12/01
 */
public class SpatialQuery extends AbstractQuery implements Serializable {

  private static final Logger logger = LoggerFactory.getLogger(SpatialQuery.class);

  public SpatialQuery(DataSet dataSet, AbstractQueryCondition abstractQueryCondition)
      throws IOException {
    super(dataSet, abstractQueryCondition);
  }

  public SpatialQuery(IndexTable targetIndexTable, AbstractQueryCondition abstractQueryCondition)
      throws IOException {
    super(targetIndexTable, abstractQueryCondition);
  }

  @Override
  public List<Trajectory> executeQuery(List<RowKeyRange> rowKeyRanges) throws IOException {
    setupTargetIndexTable();
    List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rowKeyRanges);
    SpatialQueryCondition spatialQueryCondition = (SpatialQueryCondition) abstractQueryCondition;
    QueryCondition.QueryRequest spatialQueryRequest =
        QueryCondition.QueryRequest.newBuilder()
            .addAllRange(ranges)
            .setSt(
                QueryCondition.STQueryRequest.newBuilder()
                    .setSpatialQueryType(
                        spatialQueryCondition.getQueryType()
                                == SpatialQueryCondition.SpatialQueryType.CONTAIN
                            ? QueryCondition.QueryType.CONTAIN
                            : QueryCondition.QueryType.INTERSECT)
                    .setSpatialQueryWindow(
                        QueryCondition.SpatialQueryWindow.newBuilder()
                            .setWkt(spatialQueryCondition.getQueryWindowWKT()))
                    .build())
            .setQueryOperation(QueryCondition.QueryMethod.ST)
            .build();
    return STCoprocessorQuery.executeQuery(targetIndexTable, spatialQueryRequest);
  }

  @Override
  public List<Trajectory> getFinalFilter(List<Trajectory> list) throws ParseException {
    SpatialQueryCondition spatialQueryCondition = null;
    if(abstractQueryCondition instanceof SpatialQueryCondition){
      spatialQueryCondition = (SpatialQueryCondition) abstractQueryCondition;
    }
    assert spatialQueryCondition != null;
    WKTReader wktReader = new WKTReader();
    String queryWindowWKT = spatialQueryCondition.getQueryWindowWKT();
    Geometry queryGeom = wktReader.read(queryWindowWKT);
    ArrayList<Trajectory> trajectories = new ArrayList<>();
    for (Trajectory trajectory : list) {
      if(queryGeom.intersects(trajectory.getTrajectoryFeatures().getMbr().toPolygon(4326))){
        if (queryGeom.intersects(trajectory.getLineString())){
          trajectories.add(trajectory);
        }
      }
    }
    return trajectories;
  }

  @Override
  public IndexMeta findBestIndex() {
    Map<IndexType, List<IndexMeta>> map = dataSet.getDataSetMeta().getAvailableIndexes();
    // find a spatial index
    List<IndexMeta> spatialIndexList = null;
    if (map.containsKey(IndexType.XZ2)) {
      spatialIndexList = map.get(IndexType.XZ2);
    } else if (map.containsKey(IndexType.XZ2T)) {
      spatialIndexList = map.get(IndexType.XZ2);
    }
    if (spatialIndexList != null) {
      return IndexMeta.getBestIndexMeta(spatialIndexList);
    }
    // no spatial index so we will do a full table scan, we select a main index.
    return dataSet.getDataSetMeta().getCoreIndexMeta();
  }

  @Override
  public String getQueryInfo() {
    return abstractQueryCondition.getConditionInfo();
  }
}
