package whu.edu.cn.trajlab.query.query.advanced;

import com.google.protobuf.ByteString;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.sql.SparkSession;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import scala.Tuple2;
import whu.edu.cn.trajlab.base.mbr.MinimumBoundingBox;
import whu.edu.cn.trajlab.base.point.TrajPoint;
import whu.edu.cn.trajlab.base.trajectory.Trajectory;
import whu.edu.cn.trajlab.base.util.GeoUtils;
import whu.edu.cn.trajlab.base.util.SparkUtils;
import whu.edu.cn.trajlab.db.condition.*;
import whu.edu.cn.trajlab.db.database.DataSet;
import whu.edu.cn.trajlab.db.database.meta.IndexMeta;
import whu.edu.cn.trajlab.db.database.table.IndexTable;
import whu.edu.cn.trajlab.db.datatypes.TimeLine;
import whu.edu.cn.trajlab.db.enums.IndexType;
import whu.edu.cn.trajlab.db.enums.TemporalQueryType;
import whu.edu.cn.trajlab.db.enums.TimePeriod;
import whu.edu.cn.trajlab.db.index.RowKeyRange;
import whu.edu.cn.trajlab.query.coprocessor.STCoprocessorQuery;
import whu.edu.cn.trajlab.query.coprocessor.autogenerated.QueryCondition;
import whu.edu.cn.trajlab.query.query.basic.AbstractQuery;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

/**
 * @author xuqi
 * @date 2024/01/29
 */
public class AccompanyQuery extends AbstractQuery {
  public AccompanyQuery(DataSet dataSet, AbstractQueryCondition abstractQueryCondition) {
    super(dataSet, abstractQueryCondition);
  }

  public AccompanyQuery(IndexTable targetIndexTable, AbstractQueryCondition abstractQueryCondition)
      throws IOException {
    super(targetIndexTable, abstractQueryCondition);
  }

  @Override
  public List<Trajectory> executeQuery() throws IOException {
    setupTargetIndexTable();
    AccompanyQueryCondition acq = (AccompanyQueryCondition) abstractQueryCondition;
    Trajectory centralTrajectory = acq.getCentralTrajectory();
    double disThreshold = acq.getDisThreshold();
    int k = acq.getK();
    ArrayList<Geometry> buffers = new ArrayList<>();
    ArrayList<TimeLine> timeLines = new ArrayList<>();
    double timeThreshold = acq.getTimeThreshold();
    TimePeriod timePeriod = acq.getTimePeriod();
    List<TrajPoint> pointList = centralTrajectory.getPointList();
    for (int i = 0; i <= pointList.size() - k; i++) {
      MinimumBoundingBox minimumBoundingBox =
              GeoUtils.calMinimumBoundingBox(pointList.subList(i, i + k));
      minimumBoundingBox.expandBy(GeoUtils.getDegreeFromKm(disThreshold));
      buffers.add(GeoUtils.createEnvelopeGeometry(minimumBoundingBox));
      ZonedDateTime timestampStart = pointList.get(i).getTimestamp();
      ZonedDateTime timestampEnd = pointList.get(i + k - 1).getTimestamp();
      timeLines.add(
              new TimeLine(
                      timestampStart.minus((long) timeThreshold, timePeriod.getChronoUnit()),
                      timestampEnd.plus((long) timeThreshold, timePeriod.getChronoUnit())));
    }
    List<Tuple2<AbstractQueryCondition, Integer>> stQc =
            generateSTQueryCondition(buffers, timeLines);
    HashSet<Trajectory> result = new HashSet<>();
    for (Tuple2<AbstractQueryCondition, Integer> tuple2 : stQc) {
      result.addAll(executeSTQuery(tuple2));
    }
    result.remove(centralTrajectory);
    return new ArrayList<>(result);
  }

  @Override
  public List<Trajectory> executeQuery(List<RowKeyRange> rowKeyRanges) throws IOException {
    throw new UnsupportedEncodingException();
  }

  @Override
  public List<Trajectory> getFinalFilter(List<Trajectory> list) throws ParseException {
    throw new UnsupportedOperationException();
  }

  public List<Trajectory> executeQuery(List<RowKeyRange> rowKeyRanges, Integer k)
      throws IOException {
    setupTargetIndexTable();
    List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rowKeyRanges);
    AccompanyQueryCondition acq = (AccompanyQueryCondition) abstractQueryCondition;
    QueryCondition.QueryRequest accQueryRequest =
        QueryCondition.QueryRequest.newBuilder()
            .addAllRange(ranges)
            .setAcc(
                QueryCondition.AccompanyQueryRequest.newBuilder()
                    .setDistance(GeoUtils.getDegreeFromKm(acq.getDisThreshold()))
                    .setTrajectory(ByteString.copyFrom(acq.getTrajectoryBytes()))
                    .setTimeInterval(
                        (long) acq.getTimeThreshold()
                            * acq.getTimePeriod().getChronoUnit().getDuration().toMillis())
                    .setK(acq.getK())
                    .setStartPoint(k)
                    .build())
            .setQueryOperation(QueryCondition.QueryMethod.ACCOMPANY)
            .build();
    return STCoprocessorQuery.executeQuery(targetIndexTable, accQueryRequest);
  }

  public List<Trajectory> executeSTQuery(Tuple2<AbstractQueryCondition, Integer> aqc)
      throws IOException {
    List<RowKeyRange> splitRanges = getSplitRanges(aqc._1);
    return executeQuery(splitRanges, aqc._2);
  }

  @Override
  public JavaRDD<Trajectory> getRDDQuery(SparkSession ss) throws IOException {
    setupTargetIndexTable();
    AccompanyQueryCondition acq = (AccompanyQueryCondition) abstractQueryCondition;
    Trajectory centralTrajectory = acq.getCentralTrajectory();
    double disThreshold = acq.getDisThreshold();
    int k = acq.getK();
    ArrayList<Geometry> buffers = new ArrayList<>();
    ArrayList<TimeLine> timeLines = new ArrayList<>();
    double timeThreshold = acq.getTimeThreshold();
    TimePeriod timePeriod = acq.getTimePeriod();
    List<TrajPoint> pointList = centralTrajectory.getPointList();
    for (int i = 0; i <= pointList.size() - k; i++) {
      MinimumBoundingBox minimumBoundingBox =
          GeoUtils.calMinimumBoundingBox(pointList.subList(i, i + k));
      minimumBoundingBox.expandBy(GeoUtils.getDegreeFromKm(disThreshold));
      buffers.add(GeoUtils.createEnvelopeGeometry(minimumBoundingBox));
      ZonedDateTime timestampStart = pointList.get(i).getTimestamp();
      ZonedDateTime timestampEnd = pointList.get(i + k - 1).getTimestamp();
      timeLines.add(
          new TimeLine(
              timestampStart.minus((long) timeThreshold, timePeriod.getChronoUnit()),
              timestampEnd.plus((long) timeThreshold, timePeriod.getChronoUnit())));
    }
    List<Tuple2<AbstractQueryCondition, Integer>> stQc =
        generateSTQueryCondition(buffers, timeLines);
    JavaSparkContext context = SparkUtils.getJavaSparkContext(ss);
    JavaRDD<Tuple2<AbstractQueryCondition, Integer>> qcRDD = context.parallelize(stQc);
    return qcRDD.flatMap(q -> executeSTQuery(q).iterator())
            .distinct();
  }

  public List<Tuple2<AbstractQueryCondition, Integer>> generateSTQueryCondition(
      List<Geometry> geometries, List<TimeLine> timeLines) throws IOException {
    List<Tuple2<AbstractQueryCondition, Integer>> aqc = new ArrayList<>();
    for (int i = 0; i < geometries.size(); i++) {
      SpatialQueryCondition sqc =
          new SpatialQueryCondition(
              geometries.get(i), SpatialQueryCondition.SpatialQueryType.INTERSECT);
      TemporalQueryCondition tqc =
          new TemporalQueryCondition(timeLines.get(i), TemporalQueryType.INTERSECT);
      aqc.add(new Tuple2<>(new SpatialTemporalQueryCondition(sqc, tqc), i));
    }
    return aqc;
  }

  public List<RowKeyRange> getSplitRanges(AbstractQueryCondition abQc) throws IOException {
    setupTargetIndexTable();

    return targetIndexTable.getIndexMeta().getIndexStrategy().getPartitionScanRanges(abQc);
  }

  @Override
  public IndexMeta findBestIndex() {
    Map<IndexType, List<IndexMeta>> map = dataSet.getDataSetMeta().getAvailableIndexes();
    // case 1: 无时间约束，找XZ2索引，或XZ2T索引
    if (map.containsKey(IndexType.TXZ2)) {
      return IndexMeta.getBestIndexMeta(map.get(IndexType.TXZ2));
    }
    // case 2: 有时间约束，找TXZ2索引
    else {
      if (map.containsKey(IndexType.XZ2T)) {
        return IndexMeta.getBestIndexMeta(map.get(IndexType.XZ2T));
      }
      if (map.containsKey(IndexType.TXZ2)) {
        return IndexMeta.getBestIndexMeta(map.get(IndexType.TXZ2));
      }
    }
    return null;
  }

  @Override
  public String getQueryInfo() {
    return abstractQueryCondition.getConditionInfo();
  }
}
