package whu.edu.cn.trajlab.query.query.basic;

import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.sql.SparkSession;
import whu.edu.cn.trajlab.base.util.SparkUtils;
import whu.edu.cn.trajlab.query.coprocessor.STCoprocessorQuery;
import whu.edu.cn.trajlab.db.condition.AbstractQueryCondition;
import whu.edu.cn.trajlab.db.condition.TemporalQueryCondition;
import whu.edu.cn.trajlab.db.database.DataSet;
import whu.edu.cn.trajlab.db.database.meta.IndexMeta;
import whu.edu.cn.trajlab.db.database.table.IndexTable;
import whu.edu.cn.trajlab.db.datatypes.TimeLine;
import whu.edu.cn.trajlab.db.enums.IndexType;
import whu.edu.cn.trajlab.db.enums.TemporalQueryType;
import whu.edu.cn.trajlab.db.index.RowKeyRange;
import org.apache.spark.api.java.JavaRDD;
import whu.edu.cn.trajlab.db.condition.IDTemporalQueryCondition;
import whu.edu.cn.trajlab.base.trajectory.Trajectory;
import whu.edu.cn.trajlab.query.coprocessor.autogenerated.QueryCondition;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * @author xuqi
 * @date 2023/12/01
 */
public class IDTemporalQuery extends AbstractQuery {

  public IDTemporalQuery(DataSet dataSet, AbstractQueryCondition abstractQueryCondition) {
    super(dataSet, abstractQueryCondition);
  }

  public IDTemporalQuery(IndexTable indexTable, AbstractQueryCondition abstractQueryCondition)
      throws IOException {
    super(indexTable, abstractQueryCondition);
  }

  @Override
  public JavaRDD<Trajectory> getRDDQuery(SparkSession sc) throws IOException {
    List<RowKeyRange> indexRanges = getIndexRanges();
    JavaSparkContext context = SparkUtils.getJavaSparkContext(sc);
    JavaRDD<RowKeyRange> rowKeyRangeJavaRDD = context.parallelize(indexRanges);

    return rowKeyRangeJavaRDD.mapPartitions(
        iterator -> {
          // 对每个分区中的元素进行转换操作
          List<RowKeyRange> result = new ArrayList<>();
          while (iterator.hasNext()) {
            RowKeyRange next = iterator.next();
            result.add(next);
          }
          List<Trajectory> trajectories = executeQuery(result);
          return trajectories.iterator();
        });
  }

  @Override
  public List<Trajectory> executeQuery(List<RowKeyRange> rowKeyRanges) throws IOException {
    List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rowKeyRanges);
    TemporalQueryCondition temporalQueryCondition = (TemporalQueryCondition) abstractQueryCondition;
    List<QueryCondition.TemporalQueryWindow> temporalQueryWindows =
        buildProtoTemporalWindows(temporalQueryCondition);

    QueryCondition.QueryRequest timeQueryRequest =
        QueryCondition.QueryRequest.newBuilder()
            .setTemporalQueryType(
                temporalQueryCondition.getTemporalQueryType() == TemporalQueryType.CONTAIN
                    ? QueryCondition.QueryType.CONTAIN
                    : QueryCondition.QueryType.INTERSECT)
            .setTemporalQueryWindows(
                QueryCondition.TemporalQueryWindows.newBuilder()
                    .addAllTemporalQueryWindow(temporalQueryWindows)
                    .build())
            .setOid(
                ((IDTemporalQueryCondition) abstractQueryCondition).getIdQueryCondition().getMoid())
            .addAllRange(ranges)
            .build();

    return STCoprocessorQuery.executeQuery(targetIndexTable, timeQueryRequest);
  }

  @Override
  public IndexMeta findBestIndex() {
    Map<IndexType, List<IndexMeta>> map = dataSet.getDataSetMeta().getAvailableIndexes();
    // find a time index
    List<IndexMeta> indexList = null;
    if (map.containsKey(IndexType.OBJECT_ID_T)) {
      indexList = map.get(IndexType.OBJECT_ID_T);
    }
    if (indexList != null) {
      return IndexMeta.getBestIndexMeta(indexList);
    }
    // no spatial index so we will do a full table scan, we select a main index.
    return dataSet.getDataSetMeta().getCoreIndexMeta();
  }

  @Override
  public String getQueryInfo() {
    return abstractQueryCondition.getConditionInfo();
  }

  public static List<QueryCondition.TemporalQueryWindow> buildProtoTemporalWindows(
      TemporalQueryCondition temporalQueryCondition) {
    List<QueryCondition.TemporalQueryWindow> temporalQueryWindows = new ArrayList<>();
    for (TimeLine queryWindow : temporalQueryCondition.getQueryWindows()) {
      QueryCondition.TemporalQueryWindow temporalQueryWindow =
          QueryCondition.TemporalQueryWindow.newBuilder()
              .setStartMs(queryWindow.getTimeStart().toEpochSecond())
              .setEndMs(queryWindow.getTimeEnd().toEpochSecond())
              .build();
      temporalQueryWindows.add(temporalQueryWindow);
    }
    return temporalQueryWindows;
  }
}
